{"title":"Actually Getting Flight Data (feat. httr2)","markdown":{"headingText":"Actually Getting Flight Data (feat. httr2)","headingAttr":{"id":"sec-get-data","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"Alright, I've talked your ear off (typed your eyes off?) about the project background and the mental model framing my development approach. This section actually walks you through some code! For this section, we'll be putting all of our code into an R script called ```support_functions.R```\n\n## Interacting with APIs {#sec-api}\nThere are many methods of interacting with APIs, but for this project I'll be using httr2. For a comprehensive rundown of httr2, [nothing replaces the docs](https://httr2.r-lib.org/), but I'll give a quick rundown of some overarching principles before we set up our data pipelines.\n\nA request in httr2 generally starts like this:\n```{r, eval=FALSE}\ninstall.packages(\"httr2\")\nlibrary(httr2)\n\nreq <- request(\"https://some_example.com\")\n```\n\n... where some_example.com is the base URL forming all API requests. For the OpenSky network, the root of the REST API is ```https://opensky-network.org/api```, though you could also set up the request using a specific endpoint as the base_url as well, for example, ```https://opensky-network.org/api/states/all?```\n\nThe next function following ```request()``` is usually what the request needs to pass to the API. In this project, I use the following request varieties:\n\n- ```req_url_query()```: forms API requests where the API roughly takes on the form of ```variable=value```, i.e., ```https://opensky-network.org/api/states/all?icao24=abcdefg```\n- ```req_url_path_append()```: for when you simply need to append something to the end of the base URL, i.e., ```https://api.adsbdb.com/v0/n-number/```\n- ```req_body_json()```: for when you need to pass information in a JSON to an API\n\nThese are chained together using the pipe operator like so:\n\n```{r, eval=FALSE}\nrequest(url) |> req_url_query()\n```\n\nWe then perform the request by chaining ```req_perform()``` onto it. Once we use ```req_perform()```, our request is sent! But we still need to extract our data from the request. For that, we'll use one of httr2's functions starting with *resp*. In this project, I only use one type:\n\n- ```resp_body_json()```: returns the parsed JSON information from the httr2 response object\n\nFor the rest of this section, we'll be building functions so we can send httr2 requests and get data back for our aircraft, thereby building the pipeline to supply our tables with new information updated at regular intervals throughout the day.\n\n### Interacting with the ADSBDB API {#sec-adsbdb}\nWe'll start with the most straightforward API to work with: the ADSBDB API. The ADSBDB API doesn't require any authentication and simply requires us to append some information onto a few base URLs. Among other things, the ADSBDB API allows us to switch between icao24 (or Mode-S) identification information and registration numbers, which is important for us to construct a list of aircraft from the United Fleet Google Sheet that we can check against the OpenSky API, since the OpenSky API only takes icao24 addresses.\n\nLet's start by reading through the ADSBDB API documentation for going from registration values to icao24 values.\n\n![](assets\\adsbdb_registration_icao.png)\n\nOkay, so we've got the base URL, ```https://api.adsbdb.com/v0/```, the endpoint, ```n_number/```, and what we'll query by, the registration, denoted by ```[N-NUMBER]```.\n\nTo keep it simple, we'll just treat the URL up to ```n_number/``` as the base URL when passing our url argument to ```request()```. Since the registration number is simply appended to the base URL in this case, we'll use ```req_url_path_append()```. We will wrap our httr2 request in a function. Why? So we can programmatically use our HTTP request to the RESTful API across multiple aircraft using functions like ```map()``` later on. Let's name the function something so we can easily remember what it does; maybe ```get_icao24_from_registration```? And let's call the variable we're passing registration, since that's what ```[N_NUMBER]``` serves as a stand-in for. Doing that gives us something like this:\n\n```{r}\nlibrary(httr2)\n\nget_icao24_from_registration <- function(registration) {\n  icao24 <- request(\"https://api.adsbdb.com/v0/n-number/\") |>\n    req_url_path_append(registration) |>\n    req_perform() |>\n    resp_body_json()\n\n  return(icao24)\n}\n```\n\nAlright, let's try it on registration number N37502:\n\n```{r}\nget_icao24_from_registration(\"N37502\")\n```\n\nThis is a good start. But we might want the results to come out directly instead of being nested behind ```$response```. We can change the return to ```return(icao24$response)``` to do that. We might also want to return the results in a tibble, so we can easily use the ```bind_rows()``` function from dplyr in combination with ```map()``` later to combine a bunch of results. \n\nIn order to use ```map()```, we might also want to add some error handling to our function. Seeing that ADSBDB is being continuously updated to improve its coverage of registrations to icao24 values, there may be some gaps in the data, causing the function to error out if we input a registration that hasn't been included in the database. There are several methods to deal with this, including the use of ```possibly()``` and ```safely()```, though I chose to use ```tryCatch()``` in combination with the ```logger``` package to emit an error log.\n\nLet's put all these suggestions into practice. First, we'll add the ability to export the result we want, ```icao24$response```, as a tibble.\n\n```{r}\nget_icao24_from_registration <- function(registration, return_tibble = TRUE) {\n  icao24 <- request(\"https://api.adsbdb.com/v0/n-number/\") |>\n    req_url_path_append(registration) |>\n    req_perform() |>\n    resp_body_json()\n\n  if (return_tibble) {\n    return(as_tibble(icao24$response) |> rename(icao24 = value))\n  } else {\n    return(icao24$response)\n  }\n}\n```\n\nNext, we'll wrap that in ```tryCatch()```, emitting a ```log_error()``` whenever icao24 information isn't found on a given registration.\n\n```{r}\nlibrary(logger)\n\nget_icao24_from_registration <- function(registration, return_tibble = TRUE) {\n  tryCatch(\n    {\n      icao24 <- request(\"https://api.adsbdb.com/v0/n-number/\") |>\n        req_url_path_append(registration) |>\n        req_perform() |>\n        resp_body_json()\n\n      if (return_tibble) {\n        return(as_tibble(icao24$response) |> rename(icao24 = value))\n      } else {\n        return(icao24$response)\n      }\n    },\n    error = function(e) {\n      log_error(\"No icao24 information found for registration {registration}\")\n      return(NULL)\n    }\n  )\n}\n```\n\nAnd now we'll try outputting the result again:\n\n```{r}\nget_icao24_from_registration(\"N37502\", return_tibble = FALSE)\n```\n\nVoila!\n\nI think it's useful to note things that I'd do differently if I had to do this again from scratch (now that I'm typing up this documentation after the fact). One thing I'd change is the error function in ```tryCatch()```. Reason being that I'm making a pretty substantial assumption here about the nature of the error, i.e., that the icao24/mode-S value doesn't exist, whereas the source of the error might be something different.\n\nAs such, I'd recommend doing something like this:\n\n```{r, message=TRUE}\nlibrary(logger)\n\nget_icao24_from_registration <- function(registration, return_tibble = TRUE) {\n  tryCatch(\n    {\n      icao24 <- request(\"https://api.adsbdb.com/v0/n-number/\") |>\n        req_url_path_append(registration) |>\n        req_perform() |>\n        resp_body_json()\n\n      if (return_tibble) {\n        return(as_tibble(icao24$response) |> rename(icao24 = value))\n      } else {\n        return(icao24$response)\n      }\n    },\n    error = function(e) {\n      log_error(\"{registration} encountered error {e}\")\n      return(NULL)\n    }\n  )\n}\n\nget_icao24_from_registration(\"not a real registration\", return_tibble = FALSE)\n```\n\n... which returns ```NULL``` as seen above, but also prints this message to the console:\n\n```\nERROR [2025-09-30 20:03:09] not a real registration encountered error Error in `req_perform()`:\n! HTTP 400 Bad Request.\n```\n\n... and, in fact, I've gone back and made sure ```{e}``` is included in my ```log_error()``` calls where appropriate.\n\nWe might also want a reverse function that allows us to move from icao24 numbers to registration numbers. That's fairly easy, all we have to do is create a new function with a base URL hitting the endpoint ```mode_s``` and swap ```registration``` for ```icao24```. That looks like so:\n\n```{r}\nget_registration_from_icao24 <- function(icao24, return_tibble = TRUE) {\n  tryCatch(\n    {\n      registration <- request(\"https://api.adsbdb.com/v0/mode-s/\") |>\n        req_url_path_append(icao24) |>\n        req_perform() |>\n        resp_body_json()\n\n      if (return_tibble) {\n        return(as_tibble(registration$response) |> rename(registration = value))\n      } else {\n        return(registration$response)\n      }\n    },\n    error = function(e) {\n      log_error(\"{icao24} encountered error {e}\")\n      return(NULL)\n    }\n  )\n}\n```\n\nI'm storing these functions in a file called ```support_functions.R``` which I'll call later in my other scripts, just to keep them in a separate, single source of truth.\n\n### Interacting with the adsb.lol API\nThe adsb.lol is a little trickier but still fairly friendly. Instead of ```req_url_path_append()```, we've got to use ```req_body_json()```, since the adsb.lol's routeset endpoint only accepts requests formatted as JSON. Here's the schema from the docs:\n\n```\n{\n  \"planes\": [\n    {\n      \"callsign\": \"string\",\n      \"lat\": 0,\n      \"lng\": 0\n    }\n  ]\n}\n```\n\nOkay, a little daunting if you're not used to working with JSON - speaking for myself here! Luckily LLMs were a good tool that helped me tease this out. To prepare an R object for representation as JSON, we generally use ```list()```. Likely an oversimplifcation, but in this case, each set of braces {} and brackets [] roughly represents where we need to include ```list()```. Using that rule, our JSON setup should look like this:\n\n```{r, eval=FALSE}\njson <- list(\n  planes = list(list(callsign = callsign, lat = 0, lng = 0))\n)\n```\n\n... where ```callsign``` is going to be the variable we use in a function. ```lat``` and ```lon``` are optional latitude and longitude parameters we won't concern ourselves with for the time being.\n\nAlright, so putting that together with what we've learned from working with ADSBDB, all we need to do is replace ```req_url_path_append()``` with ```req_body_json()``` and we should be good to go. Let's call this one ```get_route_information```.\n\n```{r}\nget_route_information <- function(callsign) {\n  json <- list(\n    planes = list(list(callsign = callsign, lat = 0, lng = 0))\n  )\n\n  route <- request(\"https://api.adsb.lol/api/0/routeset/\") |>\n    req_body_json(json) |>\n    req_perform() |>\n    resp_body_json()\n\n  return(route)\n}\n```\n\n... and let's try it with a random aircraft I pulled from the dashboard, N12003 operating as UAL881:\n\n```{r}\nget_route_information(\"UAL881\")\n```\n\nYeah, that doesn't look very tidy. Well, they do say that most of data work is cleaning. Let's see if we can massage this a bit. Looks like everything is stored under ```[[1]]```, so let's get ```route[[1]]``` and try putting it into a tibble.\n\n```{r}\nlibrary(tidyverse)\nlibrary(glue)\n\nget_route_information <- function(callsign) {\n  json <- list(\n    planes = list(list(callsign = callsign, lat = 0, lng = 0))\n  )\n\n  route <- request(\"https://api.adsb.lol/api/0/routeset/\") |>\n    req_body_json(json) |>\n    req_perform() |>\n    resp_body_json()\n\n  route <- route[[1]] |> as_tibble()\n\n  return(route)\n}\n\nget_route_information(\"UAL881\")\n```\n\nBetter. But the shape isn't entirely correct. If we think a little bit farther ahead to how the other data might look, we want one observation, i.e., one row, per plane. We've got two rows here, one for each airport it looks like. In fact, sometimes this API will return a multi-leg route - i.e., three rows or more! These routes are generally more common for point-to-point airlines like Southwest than they are with hub-and-spoke airlines like United. For now, to deal with these uncertain cases, we'll plan on stopping the function entirely if there's more than two rows returned by route. \n\n::: {.callout}\nIn the future, one improvement would be to take the tracks provided by OpenSky and infer the departure airport based on spatial proximity using a spatial dataset of airports.\n:::\n\nFor now, we'll focus on two-leg routes. After grabbing ```route[[1]]```, we need to pull apart the first row (origin) and second row (destination). We've also got to do something about these named lists sitting under the ``` `_airports` ``` column. Let's try using ```unnest_wider()```, separating the names with an underscore. We're also going to try and bring these columns back together in a single row, so we've got to name them something different from one another. Let's append ```origin_``` to all columns in the object for the first row, and ```destination_``` to all columns in the object for the second row. Then, let's bind the columns using ```bind_cols()```.\n\n```{r}\nget_route_information <- function(callsign) {\n  json <- list(\n    planes = list(list(callsign = callsign, lat = 0, lng = 0))\n  )\n\n  route <- request(\"https://api.adsb.lol/api/0/routeset/\") |>\n    req_body_json(json) |>\n    req_perform() |>\n    resp_body_json()\n\n  route <- route[[1]] |> as_tibble()\n  if (nrow(route) > 2) {\n    stop(\n      \"Callsign has multiple routes or a multi-leg route. Unable to determine routing.\"\n    )\n  }\n  route_origin <- route[1, ] |>\n    unnest_wider(`_airports`, names_sep = \"_\") |>\n    rename_all(~ glue(\"origin_{.x}\"))\n  route_destination <- route[2, ] |>\n    unnest_wider(`_airports`, names_sep = \"_\") |>\n    rename_all(~ glue(\"destination_{.x}\"))\n\n  route <- bind_cols(route_origin, route_destination)\n\n  return(route_origin)\n}\n\nget_route_information(\"UAL881\")\n```\n\nAlright, just a few more things to take care of. Some of these columns now have a double underscore. Additionally, we don't have the callsign info anywhere in this tibble, so we'll need to mutate that in using ```mutate(callsign = callsign)```. Let's also add some error handling similar to the other functions, where an error returns a tibble in a similar schema filled with NAs, parsed down to only the columns used by table creation functions later in the project.\n\n```{r}\nget_route_information <- function(callsign) {\n  tryCatch(\n    {\n      json <- list(\n        planes = list(list(callsign = callsign, lat = 0, lng = 0))\n      )\n\n      route <- request(\"https://api.adsb.lol/api/0/routeset/\") |>\n        req_body_json(json) |>\n        req_perform() |>\n        resp_body_json()\n\n      route <- route[[1]] |> as_tibble()\n      if (nrow(route) > 2) {\n        stop(\n          \"Callsign has multiple routes or a multi-leg route. Unable to determine routing.\"\n        )\n      }\n      route_origin <- route[1, ] |>\n        unnest_wider(`_airports`, names_sep = \"_\") |>\n        rename_all(~ glue(\"origin_{.x}\"))\n      route_destination <- route[2, ] |>\n        unnest_wider(`_airports`, names_sep = \"_\") |>\n        rename_all(~ glue(\"destination_{.x}\"))\n\n      route <- bind_cols(route_origin, route_destination) |>\n        rename_all(~ str_replace_all(.x, \"__\", \"_\")) |>\n        mutate(callsign = callsign)\n\n      return(route)\n    },\n    error = function(e) {\n      log_error(\"Error getting route info for {callsign} {e}\")\n      route <- tibble(\n        callsign = callsign,\n        origin_airports_iata = NA,\n        origin_airports_name = NA,\n        origin_airports_countryiso2 = NA,\n        origin_plausible = NA,\n        destination_airports_iata = NA,\n        destination_airports_name = NA,\n        destination_airports_countryiso2 = NA,\n        destination_plausible = NA,\n      )\n      return(route)\n    }\n  )\n}\n\nget_route_information(\"UAL881\")\n```\n\nAnd here's our final product!\n\n### Interacting with the OpenSky API {#sec-opensky}\nEven though I've listed the OpenSky API last, it isn't really *that* daunting beyond authorizing your credentials. The authorization piece adds a little extra bit of complexity, but nothing we can't handle. As alluded to in @sec-tolled-boxes, the OpenSky API uses API credits as a way to deal with demand (among other things). For non-registered users, the limit is 400 credits a day, which roughly comes out to about 100 flights a day. That's not very much. Luckily, with a simple and *free* registration, we can get ourselves up to 4,000 credits a day, or 1,000 flights a day instead! \n\n#### Interacting as an Unauthenticated User\nI'll cover the unauthenticated piece first and provide more details about authentication in the next section. We might as well use up the 400 credits we get as an unauthorized user on messing around and actually getting our functions to work, since the 400 and 4,000 are separate limits. \n\nWe want both track and state vector data for a given aircraft, defined by an icao24 address. The base URLs for those endpoints are ```https://opensky-network.org/api/states/all?``` and ```https://opensky-network.org/api/tracks/all?```. Let's start with the track information first. Taking a look at the docs:\n\n![](assets/opensky_tracks.png)\n\nWe can see that our request needs to at least pass the property icao24. Time is optional, if we had information on when we thought the given icao24 code was in the air (i.e., a time between the start and end of a given flight). Since we don't have that information, we'll just pass the icao24 code in our request. To do that, we'll use ```req_url_query()```, which is structured in a ```variable = value``` pattern, and call this function ```get_flight_track```.\n\n```{r}\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  opensky_response <- request(\"https://opensky-network.org/api/tracks/all?\") |>\n    req_url_query(icao24 = str_to_lower(icao24)) |>\n    req_perform()\n}\n```\n\nThis is the basic body of our request. Note the ```str_to_lower()``` wrapping icao24. The OpenSky API only accepts lower case icao24 addresses. To make life a little easier, I added ```str_to_lower()``` as a failsafe to make sure the request doesn't fail because of a malformed icao24 address. Before we include the code to actually get the response, we should probably add something here that we haven't added to our previous functions, which is a way to tell how many credits we have left. For the OpenSky API, this is contained in the response header ```\"X-Rate-Limit-Remaining\"```. We'll grab that information and output it to the console using ```log_info()```.\n\n```{r}\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  opensky_response <- request(\"https://opensky-network.org/api/tracks/all?\") |>\n    req_url_query(icao24 = str_to_lower(icao24)) |>\n    req_perform()\n\n  check_remaining_credits <- opensky_response |>\n    resp_header(\"X-Rate-Limit-Remaining\")\n\n  log_info(\"Remaining API credits: {check_remaining_credits}\")\n}\n```\n\n... and now we'll add the code to actually get the response:\n\n```{r}\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  opensky_response <- request(\"https://opensky-network.org/api/tracks/all?\") |>\n    req_url_query(icao24 = str_to_lower(icao24)) |>\n    req_perform()\n\n  check_remaining_credits <- opensky_response |>\n    resp_header(\"X-Rate-Limit-Remaining\")\n\n  log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n  flight_track <- opensky_response |>\n    resp_body_json() |>\n    as_tibble()\n\n  return(flight_track)\n}\n```\n\nWhat do we get? Well, depending on what time of day you run this, you might get a result, or you might not. So, for the purposes of this tutorial, I'm going to cheat a little bit, find an active flight, capture it, and store it to a CSV.\n\n```{r}\n# flight_track <- get_flight_track(\"A126CC\")\n# write_csv(flight_track, \"data/flight_track.csv\")\n\nread_csv(\"data/flight_track.csv\")\n```\n\nAlright, a few things to note here. One, even though ```path``` claims to be of type ```<lgl>``` and is full of ```NA``` values, that's because ```path``` actually comes through as a list-column. So we'll need to do that unnesting procedure that we've done many times before:\n\n```{r}\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  opensky_response <- request(\"https://opensky-network.org/api/tracks/all?\") |>\n    req_url_query(icao24 = str_to_lower(icao24)) |>\n    req_perform()\n\n  check_remaining_credits <- opensky_response |>\n    resp_header(\"X-Rate-Limit-Remaining\")\n\n  log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n  flight_track <- opensky_response |>\n    resp_body_json() |>\n    as_tibble() |>\n    unnest_wider(col = path, names_sep = \"_\")\n\n  return(flight_track)\n}\n```\n\n```{r}\n# flight_track <- get_flight_track(\"A126CC\")\n# write_csv(flight_track, \"data/flight_track_2.csv\")\n\nread_csv(\"data/flight_track_2.csv\")\n```\n\nOkay. Unlike the adsb.lol API response which returns *named* lists, the OpenSky API returns an *unnamed* list that we have to unnest. This means we get less descriptive column names when we run ```unnest_wider()```, since we're lacking the metadata that a named list gives us, hence the ```path_1```, ```path_2```, ```path_n``` schema. Luckily, if we take a look at the OpenSky API documents again, each property of the JSON response is documented by index.\n\n![](assets/opensky_tracks.png)\n\nR is a one-based indexed language, so shift every value of the index in that table by 1. Doing that, we can rename our columns by including this bit of code:\n\n```{r, eval=FALSE}\nrename(\n  timestamp = path_1,\n  latitude = path_2,\n  longitude = path_3,\n  baro_altitude = path_4,\n  true_track = path_5,\n  on_ground = path_6\n)\n```\n\nThe columns ```startTime```, ```endTime```, and ```timestamp``` are currently long numeric strings, because they represent Unix time: a running total of seconds since January 1, 1970, midnight UTC. I'm not sure about the merits of using Unix timestamp, and I won't go down that rabbit hole right now, but I'll extend you the courtesy of linking the [Wikipedia article on Unix time](https://en.wikipedia.org/wiki/Unix_time) if you're so inclined. ```lubridate```'s got a function, ```as_datetime()```, that helps us convert Unix timestamps into something more intelligible. We'll mutate across all the time columns to convert them into human (and machine) readable timestamps.\n\n```{r}\nget_flight_track <- function(icao24) {\n  opensky_response <- request(\"https://opensky-network.org/api/tracks/all?\") |>\n    req_url_query(icao24 = str_to_lower(icao24)) |>\n    req_perform()\n\n  check_remaining_credits <- opensky_response |>\n    resp_header(\"X-Rate-Limit-Remaining\")\n\n  log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n  flight_track <- opensky_response |>\n    resp_body_json() |>\n    as_tibble() |>\n    unnest_wider(col = path, names_sep = \"_\") |>\n    rename(\n      timestamp = path_1,\n      latitude = path_2,\n      longitude = path_3,\n      baro_altitude = path_4,\n      true_track = path_5,\n      on_ground = path_6\n    ) |>\n    mutate(across(c(startTime, endTime, timestamp), \\(x) as_datetime(x))) |>\n    mutate(callsign = trimws(callsign)) |>\n    arrange(timestamp)\n\n  return(flight_track)\n}\n```\n\nFinally, we're dealing with geospatial data here. This data has a bunch of rows, and that's because it has a bunch of different coordinates throughout time. For present purposes, we really just want the complete picture of an aircraft's flight path up until the point in time we pulled its data. So let's summarize the data, convert it to a simple features dataframe, and cast it to ```\"LINESTRING\"```. We'll do that by using ```st_as_sf()``` to convert the data to a simple features dataframe, specifying ```coords = c(\"longitude\", \"latitude\", \"baro_altitude\")``` as the X, Y, and Z (height) dimensions of our data. We can specify ```dim = \"XYZ\"```, though the default of this function already captures this, so it can be omitted. Finally, we need to define the projection system. The World Geodetic System, WGS, and its current version, 84, is the standard, hence we'll specify 4326 for WGS84.\n\n```{r}\nlibrary(sf)\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  opensky_response <- request(\"https://opensky-network.org/api/tracks/all?\") |>\n    req_url_query(icao24 = str_to_lower(icao24)) |>\n    req_perform()\n\n  check_remaining_credits <- opensky_response |>\n    resp_header(\"X-Rate-Limit-Remaining\")\n\n  log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n  flight_track <- opensky_response |>\n    resp_body_json() |>\n    as_tibble() |>\n    unnest_wider(col = path, names_sep = \"_\") |>\n    rename(\n      timestamp = path_1,\n      latitude = path_2,\n      longitude = path_3,\n      baro_altitude = path_4,\n      true_track = path_5,\n      on_ground = path_6\n    ) |>\n    mutate(across(c(startTime, endTime, timestamp), \\(x) as_datetime(x))) |>\n    mutate(callsign = trimws(callsign)) |>\n    arrange(timestamp)\n\n  if (as_sf) {\n    flight_track <- st_as_sf(\n      flight_track,\n      coords = c(\"longitude\", \"latitude\", \"baro_altitude\"),\n      dim = \"XYZ\",\n      crs = 4326\n    ) |>\n      group_by(icao24, callsign) |>\n      summarize(do_union = FALSE) |>\n      st_cast(\"LINESTRING\") |>\n      st_wrap_dateline()\n  }\n  return(flight_track)\n}\n```\n\nEasy, right? Well, easier than me trying to figure out why on Earth I was getting weird lines for the longest time. I'll draw special attention to two things here:\n\n1. ```summarize(do_union = FALSE)```: prevents sf from trying to union all the geometries (in this case, points) together when summarizing. If you fail to specify this argument, what you get is a weird connection of lines rather than a flight track.\n2. ```st_wrap_dateline()```: If you've ever mapped anything in the Pacific Ocean, you'll probably be painfully aware that computers seem to have a tough time with the international date line.[^1] The date line causes a discontinuity in the coordinate system, particularly on the WGS84 projection. Interactive maps generally solve this issue, but, again, if you're projecting data using WGS84, the coordinate system will have a discontinuity, and so ```sf``` will, rightfully, wrap your line around the other side of the world to make a valid, continuous geometry. ```st_wrap_dateline()``` solves this problem by detecting geometry that crosses the international date line, splitting it, and casting to ```\"MULTILINESTRING\"```.\n\n[^1]: I imagine there's an opportunity for a self-deprecating joke here. I don't want to write it out and you're probably clever enough to infer it considering I'm more content sitting in front of my computer typing this than actually going outside.\n\nI mentioned above as well as in @sec-tolled-boxes that this function will fail and consume credits if the queried icao24 address is not actually in flight at the moment. Let's add error handling for that similar to our other functions:\n\n```{r}\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  tryCatch(\n    {\n      opensky_response <- request(\n        \"https://opensky-network.org/api/tracks/all?\"\n      ) |>\n        req_url_query(icao24 = str_to_lower(icao24)) |>\n        req_perform()\n\n      check_remaining_credits <- opensky_response |>\n        resp_header(\"X-Rate-Limit-Remaining\")\n\n      log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n      flight_track <- opensky_response |>\n        resp_body_json() |>\n        as_tibble() |>\n        unnest_wider(col = path, names_sep = \"_\") |>\n        rename(\n          timestamp = path_1,\n          latitude = path_2,\n          longitude = path_3,\n          baro_altitude = path_4,\n          true_track = path_5,\n          on_ground = path_6\n        ) |>\n        mutate(across(c(startTime, endTime, timestamp), \\(x) as_datetime(x))) |>\n        mutate(callsign = trimws(callsign)) |>\n        arrange(timestamp)\n\n      if (as_sf) {\n        flight_track <- st_as_sf(\n          flight_track,\n          coords = c(\"longitude\", \"latitude\", \"baro_altitude\"),\n          dim = \"XYZ\",\n          crs = 4326\n        ) |>\n          group_by(icao24, callsign) |>\n          summarize(do_union = FALSE) |>\n          st_cast(\"LINESTRING\") |>\n          st_wrap_dateline()\n      }\n      return(flight_track)\n    },\n    error = function(e) {\n      log_error(\n        \"Error occurred when retrieving flight track for {icao24}. {e} Check your icao24 value: {icao24} may be valid but currently inactive.\"\n      )\n      flight_position <- tibble(\n        icao24 = str_to_lower(icao24),\n        on_ground = TRUE\n      )\n    }\n  )\n}\n```\n\nIf the function doesn't return any data, it could very well be the case that the aircraft associated with the icao24 address is inactive (on the ground) at the moment. For actually valid icao24 values, it seems fair to return a tibble with the icao24 value and a status of ```TRUE``` for ```on_ground```. If we were to build this out further, we'd probably want to add some validation to the user's icao24 input.\n\n:::{.callout}\nThe way I've handled the errors here is anticipation of using ```map()``` on this function, and this isn't the only way, or maybe even the best way, to achieve this goal. One could use ```possibly()``` or ```safely()``` as alternatives which will move past errors when applying this function against a vector. But, for present purposes, this is what I've went with.\n:::\n\nOkay, let's do the same thing for state vectors. A lot of this is going to be similar so I'm going to move substantially quicker through this one. The base URL this time is ```https://opensky-network.org/api/states/all?```, the arguments we need to pass (icao24) are the same, and we've got a whole bunch more return values. Spoiler: we'll need to unnest, rename, coerce Unix values, and convert to simple features like last time. What's different this time is that we've got a ```callsign``` column with some whitespace in it. We'll deal with the whitespace using ```mutate(callsign = trimws(callsign))``` to get rid of it. We'll call this function ```get_state_vector```.\n\n![](assets/opensky_states.png)\n\n```{r}\nget_state_vector <- function(icao24, as_sf = TRUE) {\n  tryCatch(\n    {\n      opensky_response <- request(\n        \"https://opensky-network.org/api/states/all?\"\n      ) |>\n        req_url_query(icao24 = str_to_lower(icao24)) |>\n        req_perform()\n\n      check_remaining_credits <- opensky_response |>\n        resp_header(\"X-Rate-Limit-Remaining\")\n\n      log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n      flight_position <- opensky_response |>\n        resp_body_json() |>\n        as_tibble() |>\n        unnest_wider(col = states, names_sep = \"_\") |>\n        rename(\n          icao24 = states_1,\n          callsign = states_2,\n          origin_country = states_3,\n          time_position = states_4,\n          last_contact = states_5,\n          longitude = states_6,\n          latitude = states_7,\n          baro_altitude = states_8,\n          on_ground = states_9,\n          velocity = states_10,\n          true_track = states_11,\n          vertical_rate = states_12,\n          sensors = states_13,\n          geo_altitude = states_14,\n          squawk = states_15,\n          special_purpose = states_16,\n          position_source = states_17\n        ) |>\n        mutate(callsign = trimws(callsign)) |>\n        mutate(across(c(time, time_position, last_contact), \\(x) {\n          as_datetime(x)\n        }))\n\n      if (as_sf) {\n        flight_position <- st_as_sf(\n          flight_position,\n          coords = c(\"longitude\", \"latitude\", \"baro_altitude\"),\n          dim = \"XYZ\",\n          crs = 4326\n        )\n      }\n\n      return(flight_position)\n    },\n    error = function(e) {\n      log_error(\n        \"Error occurred when retrieving state vector for {icao24}. {e} Check your icao24 value: {icao24} may be valid but currently inactive.\"\n      )\n      flight_position <- tibble(\n        icao24 = str_to_lower(icao24),\n        on_ground = TRUE\n      )\n    }\n  )\n}\n```\n\nLet's save this data for later using a geoparquet file.\n\n```{r}\nlibrary(sfarrow)\n\n# st_write_parquet(get_flight_track(\"A126CC\"), \"data/flight_track.parquet\")\n# st_write_parquet(get_state_vector(\"A126CC\"), \"data/state_vector.parquet\")\n\nst_read_parquet(\"data/flight_track.parquet\")\nst_read_parquet(\"data/state_vector.parquet\")\n```\n\n#### Interacting as an Authenticated User\nIf we want to up our credit limit from 400 to 4,000 we'll need to register with OpenSky. You can do that by clicking sign in [here](https://opensky-network.org/). Once you create an account, you'll see a box on the right-hand sign of your screen to issue credentials. Your credentials will come in the form of a JSON file called credentials.json.\n\nOpenSky uses an OAuth2 client credentials flow to authenticate requests to the API. All you need to know about that at the moment is ```httr2``` has a fairly straightforward way to deal with this. First, we'll need to define our ```oauth_client```:\n\n```{r}\nclient1 <-\n  oauth_client(\n    id = Sys.getenv(\"OPENSKY_CLIENT_ID\"),\n    token_url = \"https://auth.opensky-network.org/auth/realms/opensky-network/protocol/openid-connect/token\",\n    secret = Sys.getenv(\"OPENSKY_CLIENT_SECRET\"),\n    auth = \"header\"\n  )\n```\n\n... where ```token_url``` is where we get our token from, ```id``` is the ID in our credential.json file we got from OpenSky, and ```secret``` is the ```secret``` in our credential.json file.\n\nI use ```Sys.getenv()``` here for reasons I'll get into in @sec-deployment. You can use the ```keyring``` package and ```httr2``` has some built-in functions for you to use as well. But for now, let's use ```Sys.getenv()```.\n\nAs Hadley Wickham writes in the [secrets portion of the httr2 documentation](https://httr2.r-lib.org/reference/secrets.html):\n\n> While you can manage the key explicitly in a variable, it's much easier to store in an environment variable. In real life, you should NEVER use `Sys.setenv()` to create this env var because you will also store the secret in your `.Rhistory`. Instead add it to your .Renviron using `usethis::edit_r_environ()` or similar.\n\nAdd this to your .Renviron file:\n```\nOPENSKY_CLIENT_ID=\"{your_id}\"\nOPENSKY_CLIENT_SECRET=\"{your_secret}\"\n```\n\nFor example:\n```\nOPENSKY_CLIENT_ID=\"youropenskyid@whatever_this_domain_was_probably_openskyapi.com\"\nOPENSKY_CLIENT_SECRET=\"imnotputtingarealsecretinhereasanexamplewejustmetmaybegettoknowmealittlemorefirst\"\n```\n\nAfter you've done that and defined client1 somewhere in your script (you can also define it within the functions below), we'll modify our OpenSky functions slightly by adding one line: ```req_oauth_client_credentials(client1) |>```\n\n```{r}\nclient1 <-\n  oauth_client(\n    id = Sys.getenv(\"OPENSKY_CLIENT_ID\"),\n    token_url = \"https://auth.opensky-network.org/auth/realms/opensky-network/protocol/openid-connect/token\",\n    secret = Sys.getenv(\"OPENSKY_CLIENT_SECRET\"),\n    auth = \"header\"\n  )\n\n# The line we're adding:\n# req_oauth_client_credentials(client1) |>\n\nget_flight_track <- function(icao24, as_sf = TRUE) {\n  tryCatch(\n    {\n      opensky_response <- request(\n        \"https://opensky-network.org/api/tracks/all?\"\n      ) |>\n        req_oauth_client_credentials(client1) |>\n        req_url_query(icao24 = str_to_lower(icao24)) |>\n        req_perform()\n\n      check_remaining_credits <- opensky_response |>\n        resp_header(\"X-Rate-Limit-Remaining\")\n\n      log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n      flight_track <- opensky_response |>\n        resp_body_json() |>\n        as_tibble() |>\n        unnest_wider(col = path, names_sep = \"_\") |>\n        rename(\n          timestamp = path_1,\n          latitude = path_2,\n          longitude = path_3,\n          baro_altitude = path_4,\n          true_track = path_5,\n          on_ground = path_6\n        ) |>\n        mutate(across(c(startTime, endTime, timestamp), \\(x) as_datetime(x))) |>\n        mutate(callsign = trimws(callsign)) |>\n        arrange(timestamp)\n\n      if (as_sf) {\n        flight_track <- st_as_sf(\n          flight_track,\n          coords = c(\"longitude\", \"latitude\", \"baro_altitude\"),\n          dim = \"XYZ\",\n          crs = 4326\n        ) |>\n          group_by(icao24, callsign) |>\n          summarize(do_union = FALSE) |>\n          st_cast(\"LINESTRING\") |>\n          st_wrap_dateline()\n      }\n      return(flight_track)\n    },\n    error = function(e) {\n      log_error(\n        \"Error occurred when retrieving flight track for {icao24}. {e} Check your icao24 value: {icao24} may be valid but currently inactive.\"\n      )\n      flight_position <- tibble(\n        icao24 = str_to_lower(icao24),\n        on_ground = TRUE\n      )\n    }\n  )\n}\n\nget_state_vector <- function(icao24, as_sf = TRUE) {\n  tryCatch(\n    {\n      opensky_response <- request(\n        \"https://opensky-network.org/api/states/all?\"\n      ) |>\n        req_oauth_client_credentials(client1) |>\n        req_url_query(icao24 = str_to_lower(icao24)) |>\n        req_perform()\n\n      check_remaining_credits <- opensky_response |>\n        resp_header(\"X-Rate-Limit-Remaining\")\n\n      log_info(\"Remaining API credits: {check_remaining_credits}\")\n\n      flight_position <- opensky_response |>\n        resp_body_json() |>\n        as_tibble() |>\n        unnest_wider(col = states, names_sep = \"_\") |>\n        rename(\n          icao24 = states_1,\n          callsign = states_2,\n          origin_country = states_3,\n          time_position = states_4,\n          last_contact = states_5,\n          longitude = states_6,\n          latitude = states_7,\n          baro_altitude = states_8,\n          on_ground = states_9,\n          velocity = states_10,\n          true_track = states_11,\n          vertical_rate = states_12,\n          sensors = states_13,\n          geo_altitude = states_14,\n          squawk = states_15,\n          special_purpose = states_16,\n          position_source = states_17\n        ) |>\n        mutate(callsign = trimws(callsign)) |>\n        mutate(across(c(time, time_position, last_contact), \\(x) {\n          as_datetime(x)\n        }))\n\n      if (as_sf) {\n        flight_position <- st_as_sf(\n          flight_position,\n          coords = c(\"longitude\", \"latitude\", \"baro_altitude\"),\n          dim = \"XYZ\",\n          crs = 4326\n        )\n      }\n\n      return(flight_position)\n    },\n    error = function(e) {\n      log_error(\n        \"Error occurred when retrieving state vector for {icao24}. {e} Check your icao24 value: {icao24} may be valid but currently inactive.\"\n      )\n      flight_position <- tibble(\n        icao24 = str_to_lower(icao24),\n        on_ground = TRUE\n      )\n    }\n  )\n}\n```\n\nWell, that was a lot. We still don't even have all of our data yet! We're still missing our fleet information. To be continued... in the next chapter.","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"get_data.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.25","theme":["cosmo","brand","united.scss"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}